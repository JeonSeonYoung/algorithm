#include <stdio.h>
#include <stdlib.h>
typedef struct NODE{	int data;
	struct NODE* next;
}node;

typedef struct _list{
	node* head;
	node* tail;
	static int size;
}list;
void addFirst(int value);
void addLast(int value);
void add_(int value,int index);
void removeFirst();
void removeLast();
void remove_(int index);
void get_(int index);
bool contains(int value);
void clear();


void 
int main(void)
{
	list *L = (list*)malloc(sizeof(list));
	int choice;
	int value;
	int index;
	int Size;
	bool match;
	
	L->head = NULL;
	L->tail = NULL;
	L.size = 0;

	scanf("%d",&choice);
	switch(choice){
		case 1: scanf("%d",&value);
			addFirst(value);
			break;	
		case 2: scanf("%d",&value);
			addLast(value);
			break;
		case 3: scanf("%d",&value);
			addLast(value);
			break;
		case 4: removeFirst();
			break;
		case 5: removeLast();
			break;
		case 6: scanf("%d",&index);
			remove_(index);
			break;
		case 7: scanf("%d",&index);
			get_(index);
			break;
		case 8: scanf("%d",&value);
			match =contains(value);
			(match)? 
			printf("데이터%d의 값이 존재합니다.\n“,value)
			:printf("데이터%d의 값이 존재하지않습니다..\n“,value);
			break;
		case 9: printf("사이즈는 %d입니다.\n",L.size);
			break;
		default: clear();
			break;
	return 0;}


void addFirst(int value)
{
	node* NewData = (node*)malloc(sizeof(node));
	NewData-> = value;

	if(L->head==NULL && L->tail==NULL){		//데이터가 존재하지 않을 때		NewData->next =NULL;
		L->head =NewData;
		tail=NewData;
	}
	else{						//데이터가 존재할 때
		NewData->next= L->head;
		L->head = NewData;
	}
	L.size++;	
}

void addLast(int value)
{
	node* NewData = (node*)malloc(sizeof(node));
	NewData->data = value;

	if(L->head==NULL && L->tail==NULL){		//데이터가 존재하지 않을 때		NewData->next=NULL;
		L->head = NewData;
		L->tail = NewData;
	}
	else{						//데이터가 존재할 때
		NewData ->next =NULL;
		L->tail->next = NewData;
		L->tail = NewData;
	}
	L.size++;}
void add_(int value,int index)
{
	node* cur;
	node* NewData = (node*)malloc(sizeof(node));
	int i;
	
	NewData->data = value;
	cur =L->head;
	
	if(index>1 && index=<L.size){		for(i=1;i<index-1;i++)
			cur=cur->next;	//지정한 index 바로 전 node를 cur로 지정.		NewData->next = cur->next;
		cur->next = NewData;
	}
	L.size++;
}

void removeFirst()
{
	node*temp = (node*)malloc(sizeof(node));
	
	if(L.size ==1){			//리스트 크기가 1일 경우, 		temp =L->head;
		L->head = NULL;
		L->tail = NULL;
	}
	else if(L.size ==2){		//리스트 크기가 2일 경우,		temp= L->head;
		L->head = L->tail;
		free(temp);
	}
	else{				//그 외에,
		temp= L->head;
		L->head = L->head->next;
		free(temp);
	}	
	L.size--;		
}
void removeLast()
{
	node *temp = (node*)malloc(sizeof(node));
	node *cur = (node*)malloc(sizeof(node));
	int i;

	if(L.size == 1){
		L->head = NULL;
		L->tail = NULL;
	}
	else if(L.size == 2){		temp =L->tail;
		L->head = NULL;
		L->tail = L->head;
	}
	else{
		temp = L->tail;
		for(i=1;i<L.size-1;i++)
			cur = cur->next;
		cur->next = NULL;
		L->tail=Cur;
		free(temp);
	}
	L.size--;
}
void remove_(int index)
{
	node *cur= (node*)malloc(sizeof(node));
	node *temp= (node*)malloc(sizeof(node));
	int i;

	if(index == 2){
		cur = L->head->next;
		L->head->next = L->head->next->next;
		free(cur);
	} 
	else{
		cur=L->head;
		L->head->next = L->head->next->next;
		free(cur);
	}
	L.size--;
}
void get_(int index)
{
	node* cur =(node*)malloc(sizeof(node));
	int i;
	
	cur =L->head;
	for(i=1;i<index;i++)
		cur= cur->next;
	printf("%d번째 data값은 %d입니다.\n",index,cur->data);
}
bool contains(int value)
{
	node *cur=(node*)malloc(sizeof(node));
	cur =L->head;
	while(cur!=NULL){
		if(cur->data ==value)
			return 1;
	}
	return 0;
}

void clear()
{
	L->head=NULL;
	//L->head->next =NULL;
	L->tail=NULL;
	L.size= 0;
}
